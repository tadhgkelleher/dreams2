<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Oscillator Synchronization Model</title>

    <!-- Add Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
            "chart.js": "https://cdn.jsdelivr.net/npm/chart.js@4.4.3/+esm", 
            "tippy.js": "https://unpkg.com/tippy.js@6"
        }
    }
    </script>

    <style>
        /* CSS remains the same */
        :root {
            --bg-color: #000005;
            --panel-bg: rgba(20, 10, 50, 0.8);
            --accent-color: #00ccff;
            --text-color: #e0e0e0;
            --glow-color: rgba(120, 100, 255, 0.5);
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .panel {
            position: absolute;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--glow-color);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease, opacity 0.3s ease;
            z-index: 10;
        }

        .panel:hover {
            transform: translateY(-5px);
            opacity: 0.95;
        }

        #info {
            top: 20px;
            left: 20px;
            max-width: 350px;
            font-size: 14px;
        }

        #info h2 {
            margin: 0 0 10px;
            color: var(--accent-color);
        }

        #info p {
            margin: 8px 0;
            line-height: 1.5;
        }

        #resonanceStatus {
            color: #bbf0dd;
            margin-top: 10px;
            min-height: 3.5em;
            font-size: 0.95em;
        }

        #controls {
            top: 20px;
            right: 20px;
            max-width: 250px;
        }

        #controls label {
            display: flex;
            align-items: center;
            margin: 15px 0;
            font-size: 14px;
        }

        #controls input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent-color);
        }

        #controls button, #themeToggle, #pauseButton {
            margin: 10px 0;
            padding: 10px 20px;
            background: linear-gradient(45deg, var(--accent-color), #ff00cc);
            border: none;
            border-radius: 8px;
            color: #000;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        #controls button:hover, #themeToggle:hover, #pauseButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--accent-color);
        }

        #introOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 10, 0.95);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        #introContent {
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 15px;
            max-width: 700px;
            border: 1px solid var(--accent-color);
        }

        #introContent h1 {
            color: var(--accent-color);
            margin-bottom: 20px;
        }

        #introContent p {
            line-height: 1.6;
            margin-bottom: 15px;
            font-size: 0.95em;
        }

        #introContent strong {
            color: #aadeff;
        }

        #analyticsChart {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
            height: 150px;
            background: var(--panel-bg);
            border-radius: 8px;
            padding: 10px;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <!-- HTML body remains the same -->
    <div id="introOverlay">
        <div id="introContent">
            <h1>Global Oscillator Synchronization Model</h1>
            <p>This visualization models a <strong>hypothetical scenario</strong> where oscillators (representing simplified "minds" with Theta/Alpha brainwave frequencies, ~4-8Hz) couple with each other and an external pacer (Earth's Schumann Resonance, ~7.83Hz).</p>
            <p>Using the <strong>Kuramoto model</strong>, explore emergent synchronization phenomena. Adjust parameters to observe collective coherence (order parameter 'r') and dynamic patterns.</p>
            <button id="startExperienceButton">Run Simulation with Audio</button>
        </div>
    </div>

    <div id="info" class="panel" role="region" aria-label="Simulation Information">
        <h2>Oscillator Network Dynamics</h2>
        <p>Internal Oscillators: 4–8 Hz (Theta/Alpha range).<br>External Pacer (Earth): ~7.83 Hz.</p>
        <p>Order Parameter (r): <span id="orderParameter">0.000</span></p>
        <div id="resonanceStatus">Initializing System...</div>
    </div>

    <div id="controls" class="panel" role="region" aria-label="Simulation Controls">
        <label for="coupling">Coupling (K): <span id="couplingValue">2.0</span></label>
        <input type="range" id="coupling" min="0" max="10" step="0.1" value="2" aria-valuemin="0" aria-valuemax="10" aria-valuenow="2">
        <label for="numBrains">Oscillators (N): <span id="numBrainsValue">300</span></label>
        <input type="range" id="numBrains" min="50" max="700" step="25" value="300" aria-valuemin="50" aria-valuemax="700" aria-valuenow="300">
        <label for="simSpeed">Sim Speed: <span id="simSpeedValue">0.3</span></label>
        <input type="range" id="simSpeed" min="0.05" max="1" step="0.05" value="0.3" aria-valuemin="0.05" aria-valuemax="1" aria-valuenow="0.3">
        <label for="alphaCoupling">Pacer Bal. (E↔C): <span id="alphaCouplingValue">0.5</span></label>
        <input type="range" id="alphaCoupling" min="0" max="1" step="0.05" value="0.5" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0.5">
        <label for="masterVolume">Volume: <span id="volumeValue">0.3</span></label>
        <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.3" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0.3">
        <button id="pauseButton">Pause</button>
        <button id="resetButton">Reset Simulation</button>
        <button id="themeToggle">Toggle Theme</button>
    </div>

    <canvas id="analyticsChart"></canvas>

    <script type="module">
        // Update imports to use the mapped specifiers
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { Chart, registerables } from 'chart.js'; // Updated Chart.js import
        import tippy from 'tippy.js';

        // It's good practice to register Chart.js components when importing them as ES modules.
        Chart.register(...registerables);


        class OscillatorSimulation {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x050010, 0.05);
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
                this.composer = null;
                this.controls = null;
                this.audioCtx = null;
                this.masterGain = null;
                this.droneOsc = null;
                this.droneGain = null;
                this.droneLFO = null;
                this.droneLFOGain = null;
                this.pentatonicFrequencies = [];
                this.lastChimeTime = 0;
                this.CHIME_COOLDOWN = 300;
                this.lastRNormalizedForChime = 0;
                this.EARTH_RADIUS = 5;
                this.AURA_RADIUS_FACTOR = 1.08;
                this.F_E = 7.83;
                this.OMEGA_E = 2 * Math.PI * this.F_E;
                this.MIN_R_ORDER_FOR_CONNECTIONS = 0.25;
                this.CONNECTION_PHASE_THRESHOLD = Math.PI / 8;
                this.MAX_CONNECTIONS_TO_DISPLAY = 2500;
                this.EARTH_BASE_ROTATION_SPEED = 0.00015;
                this.N = 300;
                this.K = 2.0;
                this.SIMULATION_SPEED = 0.3;
                this.ALPHA_COUPLING = 0.5;
                this.r_order = 0;
                this.totalTime = 0;
                this.animationPaused = true;
                this.phases = [];
                this.intrinsicFrequencies = [];
                this.particleEnergy = [];
                this.frame_lastTime = 0;
                this.orderChart = null;
            }

            async initAudio() {
                try {
                    this.audioCtx = new AudioContext();
                    this.masterGain = this.audioCtx.createGain();
                    this.masterGain.gain.value = parseFloat(document.getElementById('masterVolume').value);
                    this.masterGain.connect(this.audioCtx.destination);

                    const filter = this.audioCtx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(1000, this.audioCtx.currentTime);

                    this.droneOsc = this.audioCtx.createOscillator();
                    this.droneGain = this.audioCtx.createGain();
                    this.droneLFO = this.audioCtx.createOscillator();
                    this.droneLFOGain = this.audioCtx.createGain();

                    this.droneOsc.type = 'sine';
                    this.droneOsc.frequency.setValueAtTime(this.F_E * 8, this.audioCtx.currentTime);
                    this.droneGain.gain.value = 0;

                    this.droneLFO.type = 'sine';
                    this.droneLFO.frequency.setValueAtTime(this.F_E, this.audioCtx.currentTime);

                    this.droneOsc.connect(this.droneGain);
                    this.droneGain.connect(filter);
                    filter.connect(this.masterGain);
                    this.droneLFO.connect(this.droneLFOGain);
                    this.droneLFOGain.connect(this.droneGain.gain);

                    this.droneLFOGain.gain.value = 0.0;
                    this.droneOsc.start();
                    this.droneLFO.start();

                    const rootFreq = 261.63;
                    const intervals = [0, 2, 4, 7, 9, 12, 14];
                    this.pentatonicFrequencies = intervals.map(interval => rootFreq * Math.pow(2, interval / 12));
                } catch (e) {
                    console.error('Audio initialization failed:', e);
                    document.getElementById('resonanceStatus').textContent = 'Audio unavailable. Simulation running without sound.';
                }
            }

            playPentatonicChime() {
                if (!this.audioCtx || this.audioCtx.currentTime - this.lastChimeTime < this.CHIME_COOLDOWN / 1000) return;
                this.lastChimeTime = this.audioCtx.currentTime;

                const freqIndex = Math.floor(Math.random() * this.pentatonicFrequencies.length);
                const frequency = this.pentatonicFrequencies[freqIndex];

                const chimeOsc = this.audioCtx.createOscillator();
                const chimeGain = this.audioCtx.createGain();

                chimeOsc.type = 'triangle';
                chimeOsc.frequency.setValueAtTime(frequency, this.audioCtx.currentTime);
                chimeGain.gain.setValueAtTime(0, this.audioCtx.currentTime);
                chimeGain.gain.linearRampToValueAtTime(0.4 * (0.2 + this.r_order * 0.8), this.audioCtx.currentTime + 0.05);
                chimeGain.gain.exponentialRampToValueAtTime(0.0001, this.audioCtx.currentTime + 1.2 + this.r_order);

                chimeOsc.connect(chimeGain).connect(this.masterGain);
                chimeOsc.start(this.audioCtx.currentTime);
                chimeOsc.stop(this.audioCtx.currentTime + 1.5 + this.r_order);
            }

            updateAudio() {
                if (!this.audioCtx) return;
                const targetDroneGain = 0.01 + this.r_order * 0.15;
                this.droneGain.gain.setTargetAtTime(targetDroneGain, this.audioCtx.currentTime, 0.1);
                const targetLFODepth = 0.05 + this.r_order * 0.4;
                this.droneLFOGain.gain.setTargetAtTime(targetLFODepth * targetDroneGain, this.audioCtx.currentTime, 0.1);

                const currentRNormalized = Math.floor(this.r_order * 10);
                if (currentRNormalized > this.lastRNormalizedForChime && this.r_order > 0.2) {
                    this.playPentatonicChime();
                    this.lastRNormalizedForChime = currentRNormalized;
                } else if (this.r_order < 0.1) {
                    this.lastRNormalizedForChime = 0;
                }
            }

            initScene() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.body.appendChild(this.renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0x706090, 0.8);
                this.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(5, 10, 7);
                this.scene.add(directionalLight);

                const renderPass = new RenderPass(this.scene, this.camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.9, 0.6, 0.5);
                bloomPass.threshold = 0.4;
                bloomPass.strength = 0.8;
                bloomPass.radius = 0.5;

                const vignettePass = new ShaderPass({
                    uniforms: {
                        tDiffuse: { value: null },
                        offset: { value: 1.0 },
                        darkness: { value: 1.0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D tDiffuse;
                        uniform float offset;
                        uniform float darkness;
                        varying vec2 vUv;
                        void main() {
                            vec4 color = texture2D(tDiffuse, vUv);
                            float dist = distance(vUv, vec2(0.5));
                            color.rgb *= smoothstep(0.8, offset * 0.799, dist * (darkness + offset));
                            gl_FragColor = color;
                        }
                    `
                });

                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(renderPass);
                this.composer.addPass(bloomPass);
                this.composer.addPass(vignettePass);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.minDistance = this.EARTH_RADIUS * 1.5;
                this.controls.maxDistance = this.EARTH_RADIUS * 5;

                this.camera.position.set(0, this.EARTH_RADIUS * 0.3, this.EARTH_RADIUS * 2.8);
                this.camera.lookAt(0, 0, 0);
            }

            initEarth() {
                if (this.earth) this.scene.remove(this.earth);
                const earthGeometry = new THREE.SphereGeometry(this.EARTH_RADIUS, 64, 64);
                const earthMaterial = new THREE.MeshStandardMaterial({
                    color: 0x204080,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.15,
                    emissive: 0x102040,
                    emissiveIntensity: 0.5,
                    roughness: 0.7,
                    metalness: 0.3
                });
                this.earth = new THREE.Mesh(earthGeometry, earthMaterial);
                this.scene.add(this.earth);
            }

            initAura() {
                if (this.aura) this.scene.remove(this.aura);
                const auraGeometry = new THREE.SphereGeometry(this.EARTH_RADIUS * this.AURA_RADIUS_FACTOR, 64, 64);
                const auraMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        orderParameter: { value: 0.0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        uniform float time;
                        void main() {
                            vUv = uv;
                            vec3 pos = position;
                            pos += normal * sin(time + pos.x * 2.0) * 0.05;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float orderParameter;
                        varying vec2 vUv;
                        void main() {
                            float glow = 0.3 + 0.7 * sin(time + vUv.x * 10.0 + vUv.y * 5.0);
                            vec3 color = mix(vec3(0.0, 0.6, 1.0), vec3(0.2, 0.8, 1.0), orderParameter);
                            gl_FragColor = vec4(color, 0.05 + orderParameter * 0.15 * glow);
                        }
                    `,
                    transparent: true,
                    wireframe: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                this.aura = new THREE.Mesh(auraGeometry, auraMaterial);
                this.scene.add(this.aura);
            }

            initParticles() {
                if (this.particleSystem) this.scene.remove(this.particleSystem);
                if (this.particlesGeometry) this.particlesGeometry.dispose();
                if (this.particleMaterial) this.particleMaterial.dispose();

                this.particlesGeometry = new THREE.InstancedBufferGeometry();
                // THREE.SphereGeometry has been renamed to THREE.SphereGeometry
                // Correcting if it was a typo, otherwise it's fine. (It was SphereGeometry, which is correct)
                const baseGeometry = new THREE.SphereGeometry(0.05, 8, 8); 
                // The warning "Rather than copying BufferGeometries, consider using .clone() or .copy() with an BufferGeometry an argument."
                // suggests using baseGeometry.clone() or this.particlesGeometry.copy(baseGeometry.toNonIndexed()) if issues arise with instancing.
                // However, .copy(baseGeometry) is standard for setting up an InstancedBufferGeometry's attributes from a template.
                this.particlesGeometry.copy(baseGeometry);


                const instancePositions = new Float32Array(this.N * 3);
                const instanceColors = new Float32Array(this.N * 3);
                const instanceSizes = new Float32Array(this.N);

                this.phases = [];
                this.intrinsicFrequencies = [];
                this.particleEnergy = [];

                for (let i = 0; i < this.N; i++) {
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r_particle = (0.2 + Math.random() * 0.7) * this.EARTH_RADIUS;
                    instancePositions[i * 3] = r_particle * Math.sin(phi) * Math.cos(theta);
                    instancePositions[i * 3 + 1] = r_particle * Math.sin(phi) * Math.sin(theta);
                    instancePositions[i * 3 + 2] = r_particle * Math.cos(phi);
                    instanceColors[i * 3] = 0.5;
                    instanceColors[i * 3 + 1] = 0.2;
                    instanceColors[i * 3 + 2] = 0.8;
                    instanceSizes[i] = 0.1 + Math.random() * 0.08;
                    this.phases.push(Math.random() * 2 * Math.PI);
                    this.intrinsicFrequencies.push(4 + Math.random() * 4);
                    this.particleEnergy.push(Math.random());
                }

                this.particlesGeometry.setAttribute('instancePosition', new THREE.InstancedBufferAttribute(instancePositions, 3));
                this.particlesGeometry.setAttribute('instanceColor', new THREE.InstancedBufferAttribute(instanceColors, 3));
                this.particlesGeometry.setAttribute('instanceSize', new THREE.InstancedBufferAttribute(instanceSizes, 1));
                
                // ShaderMaterial.vertexColors is deprecated.
                // The current shader uses `attribute vec3 instanceColor; varying vec3 vColor; vColor = instanceColor;`
                // and `vertexColors: true` is set on the material.
                // For modern Three.js (r150+), `vertexColors: true` should be removed if colors are supplied via attributes.
                // The shader already correctly uses `instanceColor` attribute.
                // The `vertexColors: true` flag is for when geometry.attributes.color is used.
                // Here we use instanced attributes, so `vertexColors:true` might not be strictly needed or could be misleading.
                // However, often it's harmless if the shader correctly picks up attributes.
                // For clarity, removing if it's not directly used by the shader for non-instanced geometry color.
                // Let's keep it for now as the example worked, but it's a point of attention for future Three.js versions.

                this.particleMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        globalOrder: { value: 0.0 },
                        pulseFactor: { value: 1.0 }
                    },
                    vertexShader: `
                        attribute vec3 instancePosition;
                        attribute vec3 instanceColor; // This is used
                        attribute float instanceSize;
                        varying vec3 vColor;
                        uniform float time;
                        uniform float globalOrder;
                        uniform float pulseFactor;
                        void main() {
                            vColor = instanceColor; // Passed to fragment shader
                            vec4 mvPosition = modelViewMatrix * vec4(instancePosition, 1.0);
                            float pulse = 1.0 + 0.5 * sin(time * 5.0 + globalOrder * 10.0) * pulseFactor;
                            gl_Position = projectionMatrix * mvPosition;
                            gl_PointSize = instanceSize * (1.0 + globalOrder * 2.0) * pulse * (200.0 / -mvPosition.z);
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor; // Received from vertex shader
                        uniform float time;
                        void main() {
                            float alpha = 0.55 + 0.45 * sin(time * 12.0 + gl_FragCoord.x * 0.15 + gl_FragCoord.y * 0.05);
                            if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.47) discard;
                            gl_FragColor = vec4(vColor, alpha); // vColor is used here
                        }
                    `,
                    transparent: true,
                    // vertexColors: true, // This can often be removed if using custom attributes for color like instanceColor
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                this.particleSystem = new THREE.Mesh(this.particlesGeometry, this.particleMaterial);
                this.scene.add(this.particleSystem);
            }

            initResonancePlane() {
                if (this.resonancePlane) this.scene.remove(this.resonancePlane);
                const planeGeometry = new THREE.PlaneGeometry(this.EARTH_RADIUS * 3.5, this.EARTH_RADIUS * 3.5, 48, 48);
                const planeMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        orderParameter: { value: 0.0 },
                        baseColor: { value: new THREE.Color(0x55aaff) },
                        glowColor: { value: new THREE.Color(0xaadeff) }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        uniform float time;
                        uniform float orderParameter;
                        void main() {
                            vUv = uv;
                            vec3 pos = position;
                            float dist = length(pos.xy);
                            float wave1 = sin(dist * 3.0 - time * 2.5 + orderParameter * 7.0) * 0.2 * orderParameter;
                            float wave2 = cos(dist * 5.0 + time * 1.5 - orderParameter * 4.0) * 0.15 * orderParameter;
                            pos.z += (wave1 + wave2) * (1.0 - smoothstep(0.0, 8.0, dist));
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec2 vUv;
                        uniform float time;
                        uniform float orderParameter;
                        uniform vec3 baseColor;
                        uniform vec3 glowColor;
                        void main() {
                            float op = max(0.0, orderParameter - 0.1) * 3.0;
                            float pattern = 0.4 + 0.6 * sin(vUv.x * 30.0 + vUv.y * 5.0 + time * 2.0 + orderParameter * 15.0);
                            pattern *= (0.4 + 0.6 * cos(vUv.y * 25.0 - time * 1.5 + orderParameter * 10.0));
                            op = clamp(op * pattern, 0.0, 0.8);
                            float edgeFactor = 1.0 - smoothstep(0.30, 0.5, length(vUv - 0.5));
                            op *= edgeFactor;
                            vec3 color = mix(baseColor, glowColor, smoothstep(0.15, 0.75, orderParameter));
                            gl_FragColor = vec4(color, op);
                        }
                    `,
                    side: THREE.DoubleSide,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });
                this.resonancePlane = new THREE.Mesh(planeGeometry, planeMaterial);
                this.resonancePlane.rotation.x = Math.PI / 2;
                this.resonancePlane.position.y = -this.EARTH_RADIUS * 0.05;
                this.scene.add(this.resonancePlane);
            }

            initLineConnections() {
                if (this.lineConnectionSystem) this.scene.remove(this.lineConnectionSystem);
                if (this.lineGeometry) this.lineGeometry.dispose();
                if (this.lineMaterial) this.lineMaterial.dispose();
                this.lineGeometry = new THREE.BufferGeometry();
                this.lineMaterial = new THREE.LineBasicMaterial({
                    color: 0x99bbff,
                    transparent: true,
                    opacity: 0,
                    linewidth: 1, // Note: linewidth parameter has limitations in WebGL. Often stays 1.
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                this.lineConnectionSystem = new THREE.LineSegments(this.lineGeometry, this.lineMaterial);
                this.scene.add(this.lineConnectionSystem);
            }

            initChart() {
                const ctx = document.getElementById('analyticsChart').getContext('2d');
                this.orderChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Order Parameter (r)',
                            data: [],
                            borderColor: '#00ccff',
                            backgroundColor: 'rgba(0, 204, 255, 0.2)',
                            fill: false,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { display: false, ticks: { color: '#e0e0e0' } }, // Added ticks color for theme consistency
                            y: { min: 0, max: 1, title: { display: true, text: 'r', color: '#e0e0e0' }, ticks: { color: '#e0e0e0' } } // Added ticks color
                        },
                        plugins: { legend: { labels: { color: '#e0e0e0' } } }
                    }
                });
            }

            updateChart() {
                if (!this.orderChart) return; // Guard against chart not being initialized
                this.orderChart.data.labels.push(this.totalTime.toFixed(2));
                this.orderChart.data.datasets[0].data.push(this.r_order);
                if (this.orderChart.data.labels.length > 100) {
                    this.orderChart.data.labels.shift();
                    this.orderChart.data.datasets[0].data.shift();
                }
                this.orderChart.update();
            }

            updatePhases(deltaTimeEffective) {
                if (this.animationPaused || !this.phases || this.phases.length !== this.N || this.N === 0 || !this.particlesGeometry || !this.particlesGeometry.attributes.instanceColor) return;
                const earthPhase = (this.OMEGA_E * this.totalTime) % (2 * Math.PI);
                let sumCos = 0, sumSin = 0;
                for (let i = 0; i < this.N; i++) {
                    sumCos += Math.cos(this.phases[i]);
                    sumSin += Math.sin(this.phases[i]);
                }
                this.r_order = this.N > 0 ? Math.sqrt(sumCos * sumCos + sumSin * sumSin) / this.N : 0;
                const psi_collective = this.N > 0 ? Math.atan2(sumSin, sumCos) : 0;
                const currentParticleColors = this.particlesGeometry.attributes.instanceColor.array;
                const currentParticlePositions = this.particlesGeometry.attributes.instancePosition.array;
                const tempColor = new THREE.Color();

                for (let i = 0; i < this.N; i++) {
                    const omega_i = 2 * Math.PI * this.intrinsicFrequencies[i];
                    const earthInteractionTerm = (1 - this.ALPHA_COUPLING) * this.K * Math.sin(earthPhase - this.phases[i]);
                    const collectiveInteractionTerm = this.ALPHA_COUPLING * this.K * this.r_order * Math.sin(psi_collective - this.phases[i]);
                    this.phases[i] += (omega_i + earthInteractionTerm + collectiveInteractionTerm) * deltaTimeEffective;
                    this.phases[i] = (this.phases[i] % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
                    const phaseDifferenceToEarth = Math.abs(this.phases[i] - earthPhase) % (2 * Math.PI);
                    const syncFactorEarth = Math.cos(phaseDifferenceToEarth / 2);
                    const phaseDifferenceToCollective = Math.abs(this.phases[i] - psi_collective) % (2 * Math.PI);
                    const syncFactorCollective = Math.cos(phaseDifferenceToCollective / 2);
                    this.particleEnergy[i] = THREE.MathUtils.lerp(this.particleEnergy[i], (syncFactorEarth + syncFactorCollective) / 2, 0.1);
                    const hue = 0.6 + this.particleEnergy[i] * 0.3;
                    const saturation = 0.5 + this.particleEnergy[i] * 0.5;
                    const lightness = 0.4 + this.particleEnergy[i] * 0.4;
                    tempColor.setHSL(hue, saturation, lightness);
                    currentParticleColors[i * 3] = tempColor.r;
                    currentParticleColors[i * 3 + 1] = tempColor.g;
                    currentParticleColors[i * 3 + 2] = tempColor.b;
                    currentParticlePositions[i * 3 + 1] += (Math.random() - 0.5) * 0.005 * (1 - this.particleEnergy[i]);
                    const distSq = currentParticlePositions[i * 3] ** 2 + currentParticlePositions[i * 3 + 1] ** 2 + currentParticlePositions[i * 3 + 2] ** 2;
                    if (distSq > (this.EARTH_RADIUS * 0.9) ** 2) {
                        currentParticlePositions[i * 3] *= 0.995;
                        currentParticlePositions[i * 3 + 1] *= 0.995;
                        currentParticlePositions[i * 3 + 2] *= 0.995;
                    }
                }
                this.particlesGeometry.attributes.instancePosition.needsUpdate = true;
                this.particlesGeometry.attributes.instanceColor.needsUpdate = true;
                if (this.resonancePlane && this.resonancePlane.material.uniforms) {
                    this.resonancePlane.material.uniforms.orderParameter.value = this.r_order;
                    this.resonancePlane.material.uniforms.time.value = this.totalTime;
                    const planeScale = 1 + this.r_order * this.K * 0.02;
                    this.resonancePlane.scale.set(planeScale, planeScale, 1);
                }
                if (this.particleMaterial && this.particleMaterial.uniforms) {
                    this.particleMaterial.uniforms.time.value = this.totalTime;
                    this.particleMaterial.uniforms.globalOrder.value = this.r_order;
                }
            }

            updateConnections() {
                if (this.animationPaused || !this.lineConnectionSystem || !this.particlesGeometry || !this.particlesGeometry.attributes.instancePosition || this.N === 0) {
                    if (this.lineConnectionSystem && this.lineConnectionSystem.material) this.lineConnectionSystem.material.opacity = 0;
                    return;
                }
                const lineVertices = [];
                let connectionsDrawn = 0;
                const particlePos = this.particlesGeometry.attributes.instancePosition.array;
                if (this.r_order > this.MIN_R_ORDER_FOR_CONNECTIONS) {
                    for (let i = 0; i < this.N; i++) {
                        if (connectionsDrawn >= this.MAX_CONNECTIONS_TO_DISPLAY) break;
                        for (let j = i + 1; j < this.N; j++) {
                            if (connectionsDrawn >= this.MAX_CONNECTIONS_TO_DISPLAY) break;
                            let phaseDiff = Math.abs(this.phases[i] - this.phases[j]);
                            phaseDiff = Math.min(phaseDiff, 2 * Math.PI - phaseDiff);
                            if (phaseDiff < this.CONNECTION_PHASE_THRESHOLD * (1.5 - this.particleEnergy[i]) * (1.5 - this.particleEnergy[j])) {
                                const connectionStrength = this.particleEnergy[i] * this.particleEnergy[j];
                                if (Math.random() < connectionStrength * 0.5) {
                                    lineVertices.push(particlePos[i * 3], particlePos[i * 3 + 1], particlePos[i * 3 + 2]);
                                    lineVertices.push(particlePos[j * 3], particlePos[j * 3 + 1], particlePos[j * 3 + 2]);
                                    connectionsDrawn++;
                                }
                            }
                        }
                    }
                }
                if (this.lineConnectionSystem.geometry) { // Ensure geometry exists
                    if (lineVertices.length > 0) {
                        this.lineConnectionSystem.geometry.setAttribute('position', new THREE.Float32BufferAttribute(lineVertices, 3));
                        this.lineConnectionSystem.geometry.attributes.position.needsUpdate = true;
                        const baseOpacity = Math.min(0.05, (this.r_order - this.MIN_R_ORDER_FOR_CONNECTIONS) * 0.5);
                        this.lineConnectionSystem.material.opacity = baseOpacity + Math.min(0.5, this.r_order * 0.8);
                        const lineHue = 0.55 + this.r_order * 0.3;
                        this.lineConnectionSystem.material.color.setHSL(lineHue, 0.7, 0.5 + this.r_order * 0.2);
                    } else {
                        this.lineConnectionSystem.material.opacity = 0;
                        // Optional: clear geometry if no lines to draw to free memory, or set count to 0
                        this.lineConnectionSystem.geometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
                        this.lineConnectionSystem.geometry.attributes.position.needsUpdate = true;
                    }
                }
            }

            updateResonanceStatusText() {
                const el = document.getElementById('resonanceStatus');
                if (this.animationPaused && !this.audioCtx) {
                    el.textContent = "Click 'Run Simulation' to begin.";
                    return;
                }
                if (this.animationPaused && this.audioCtx) {
                    el.textContent = "Simulation Paused. Audio may continue.";
                    return;
                }
                if (this.r_order < 0.15) el.textContent = "Low Coherence: Oscillators unsynchronized.";
                else if (this.r_order < 0.35) el.textContent = "Emerging Coherence: Partial phase-locking.";
                else if (this.r_order < 0.6) el.textContent = "Significant Coherence: Strong synchronization.";
                else el.textContent = "High Global Coherence: Near full synchronization.";
            }

            animate(time) {
                requestAnimationFrame((t) => this.animate(t));
                if (this.animationPaused && time !== 0 && this.frame_lastTime !==0) return; // Allow first frame if time is 0 or frame_lastTime is 0
                
                const now = time * 0.001;
                const deltaTime = (this.frame_lastTime === 0) ? 0.016 : now - this.frame_lastTime; // Handle first frame
                this.frame_lastTime = now;

                const effectiveDeltaTime = Math.min(deltaTime, 0.1) * this.SIMULATION_SPEED;

                if (this.N > 0 && this.phases && this.phases.length > 0 && !this.animationPaused) {
                    this.totalTime += effectiveDeltaTime;
                }

                if (this.earth && this.earth.material) {
                    this.earth.rotation.y += this.EARTH_BASE_ROTATION_SPEED * this.SIMULATION_SPEED * 60 * deltaTime;
                    this.earth.material.emissiveIntensity = 0.3 + this.r_order * 0.4;
                    this.earth.material.opacity = 0.1 + this.r_order * 0.08;
                }
                if (this.aura && this.aura.material && this.aura.material.uniforms) {
                    this.aura.rotation.y += (this.EARTH_BASE_ROTATION_SPEED * 1.5) * this.SIMULATION_SPEED * 60 * deltaTime;
                    this.aura.rotation.x += (this.EARTH_BASE_ROTATION_SPEED * 0.8) * this.SIMULATION_SPEED * 60 * deltaTime;
                    const pulse = 1 + 0.05 * Math.sin(this.totalTime * this.OMEGA_E * 0.2) * (1 + this.K * 0.01 + this.r_order * 1.5);
                    this.aura.scale.set(pulse, pulse, pulse);
                    this.aura.material.uniforms.time.value = this.totalTime;
                    this.aura.material.uniforms.orderParameter.value = this.r_order;
                }

                if (this.N > 0 && this.phases && this.phases.length > 0) {
                    if(!this.animationPaused) this.updatePhases(effectiveDeltaTime);
                    this.updateConnections(); // Connections might still need to update based on r_order even if paused
                } else {
                     this.updateConnections(); // Ensure connections are hidden if N=0
                }


                if(!this.animationPaused) this.updateAudio();
                document.getElementById('orderParameter').textContent = this.r_order.toFixed(3);
                this.updateResonanceStatusText();
                if(!this.animationPaused) this.updateChart();
                
                if(this.controls) this.controls.update();
                if(this.composer) this.composer.render();
            }

            resetSimulation() {
                this.K = 2.0;
                // N is set by slider, but ensure it's read correctly
                this.N = parseInt(document.getElementById('numBrains').value); 
                this.SIMULATION_SPEED = 0.3;
                this.ALPHA_COUPLING = 0.5;

                document.getElementById('coupling').value = this.K;
                // numBrains is already set by its own event listener
                document.getElementById('simSpeed').value = this.SIMULATION_SPEED;
                document.getElementById('alphaCoupling').value = this.ALPHA_COUPLING;

                document.getElementById('couplingValue').textContent = this.K.toFixed(1);
                document.getElementById('numBrainsValue').textContent = this.N; // ensure UI matches
                document.getElementById('simSpeedValue').textContent = this.SIMULATION_SPEED.toFixed(2);
                document.getElementById('alphaCouplingValue').textContent = this.ALPHA_COUPLING.toFixed(2);
                
                this.totalTime = 0;
                this.r_order = 0;
                this.lastRNormalizedForChime = 0;
                document.getElementById('orderParameter').textContent = this.r_order.toFixed(3);
                
                // Re-initialize particles only if N > 0 and simulation is not paused (or about to run)
                // If paused, particles will init when resumed or N changes.
                if (this.N > 0) { // Always re-init particles on reset if N>0
                    this.initParticles();
                } else { // If N becomes 0, clear particles explicitly
                     if (this.particleSystem) this.scene.remove(this.particleSystem);
                     if (this.particlesGeometry) this.particlesGeometry.dispose();
                }
                this.updateConnections(); // Update connections based on new state
                
                if(this.orderChart) {
                    this.orderChart.data.labels = [];
                    this.orderChart.data.datasets[0].data = [];
                    this.orderChart.update();
                }
                this.updateResonanceStatusText();
            }

            init() {
                this.initScene();
                this.initEarth();
                this.initAura();
                // Particles are initialized on simulation start or N change, or reset
                // this.initParticles(); // Defer this until N is confirmed / sim starts
                this.initResonancePlane();
                this.initLineConnections();
                this.initChart();

                document.getElementById('couplingValue').textContent = this.K.toFixed(1);
                document.getElementById('numBrainsValue').textContent = this.N;
                document.getElementById('simSpeedValue').textContent = this.SIMULATION_SPEED.toFixed(2);
                document.getElementById('alphaCouplingValue').textContent = this.ALPHA_COUPLING.toFixed(2);
                document.getElementById('volumeValue').textContent = parseFloat(document.getElementById('masterVolume').value).toFixed(2);

                document.getElementById('coupling').addEventListener('input', (e) => {
                    this.K = parseFloat(e.target.value);
                    document.getElementById('couplingValue').textContent = this.K.toFixed(1);
                });
                document.getElementById('numBrains').addEventListener('input', (e) => {
                    this.N = parseInt(e.target.value);
                    document.getElementById('numBrainsValue').textContent = this.N;
                    if (this.N > 0 && !this.animationPaused) { // Only re-init if running
                        this.initParticles(); // This re-randomizes phases and frequencies
                    } else if (this.N === 0 && this.particleSystem) {
                        this.scene.remove(this.particleSystem);
                        if(this.particlesGeometry) this.particlesGeometry.dispose();
                        this.phases = []; // Clear phase data
                        this.intrinsicFrequencies = [];
                        this.particleEnergy = [];
                    }
                    this.updateConnections(); // Update connections based on new N
                });
                document.getElementById('simSpeed').addEventListener('input', (e) => {
                    this.SIMULATION_SPEED = parseFloat(e.target.value);
                    document.getElementById('simSpeedValue').textContent = this.SIMULATION_SPEED.toFixed(2);
                });
                document.getElementById('alphaCoupling').addEventListener('input', (e) => {
                    this.ALPHA_COUPLING = parseFloat(e.target.value);
                    document.getElementById('alphaCouplingValue').textContent = this.ALPHA_COUPLING.toFixed(2);
                });
                document.getElementById('masterVolume').addEventListener('input', (e) => {
                    if (this.masterGain) this.masterGain.gain.value = parseFloat(e.target.value);
                    document.getElementById('volumeValue').textContent = parseFloat(e.target.value).toFixed(2);
                });
                document.getElementById('pauseButton').addEventListener('click', () => {
                    this.animationPaused = !this.animationPaused;
                    document.getElementById('pauseButton').textContent = this.animationPaused ? 'Resume' : 'Pause';
                    if (!this.animationPaused && this.N > 0 && (!this.phases || this.phases.length !== this.N)) {
                        // If resuming and particles need init (e.g. N changed while paused)
                        this.initParticles();
                    }
                    if(!this.animationPaused && this.frame_lastTime === 0) { // If resuming from a fully stopped state
                         this.animate(performance.now()); // Kickstart animation loop if it wasn't running
                    }
                    this.updateResonanceStatusText();
                });
                document.getElementById('resetButton').addEventListener('click', () => this.resetSimulation());
                document.getElementById('startExperienceButton').addEventListener('click', async () => {
                    await this.initAudio(); // Init audio first
                    document.getElementById('introOverlay').style.display = 'none';
                    this.animationPaused = false; // Set to not paused
                    document.getElementById('pauseButton').textContent = 'Pause'; // Update button text
                    if (this.N > 0) { // Initialize particles based on current N
                        this.initParticles(); 
                    }
                    this.updateConnections(); // Update connections
                    this.updateResonanceStatusText();
                    this.frame_lastTime = 0; // Reset last frame time to ensure smooth start
                    this.animate(performance.now()); // Start animation loop
                });
                document.getElementById('themeToggle').addEventListener('click', () => {
                    const rootStyle = document.documentElement.style;
                    const currentBgColor = rootStyle.getPropertyValue('--bg-color');
                    const newTextColor = currentBgColor === '#000005' ? '#333333' : '#e0e0e0';
                    
                    rootStyle.setProperty('--bg-color', currentBgColor === '#000005' ? '#f0f0f5' : '#000005');
                    rootStyle.setProperty('--panel-bg', rootStyle.getPropertyValue('--panel-bg') === 'rgba(20, 10, 50, 0.8)' ? 'rgba(255, 255, 255, 0.8)' : 'rgba(20, 10, 50, 0.8)');
                    rootStyle.setProperty('--text-color', newTextColor);
                    
                    if (this.orderChart && this.orderChart.options.plugins.legend.labels) {
                        this.orderChart.options.plugins.legend.labels.color = newTextColor;
                        this.orderChart.options.scales.x.ticks.color = newTextColor;
                        this.orderChart.options.scales.y.ticks.color = newTextColor;
                        this.orderChart.options.scales.y.title.color = newTextColor;
                        this.orderChart.update();
                    }
                });

                tippy('#coupling', { content: 'Controls the strength of interaction between oscillators and the external pacer.' });
                tippy('#numBrains', { content: 'Number of oscillators in the simulation.' });
                tippy('#simSpeed', { content: 'Adjusts the speed of the simulation.' });
                tippy('#alphaCoupling', { content: 'Balances coupling between external pacer and collective oscillators.' });
                tippy('#masterVolume', { content: 'Controls the audio volume of the simulation.' });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    if(this.composer) this.composer.setSize(window.innerWidth, window.innerHeight);
                });

                this.updateResonanceStatusText(); // Initial status update
                // Initial call to animate can be removed if startExperienceButton is the only entry point
                // this.animate(0); // Start animation loop in paused state if not auto-starting
            }
        }

        const sim = new OscillatorSimulation();
        sim.init();
        // The simulation will effectively start once "Run Simulation" is clicked.
        // If you want it to render something before that (e.g. the paused Earth),
        // you might call sim.animate(0) once after init, but ensure animationPaused is true.
        // Current setup: animationPaused is true by default. animate() will do one render pass
        // if called with time=0, then stop if paused.
        // Or, better, the first render can happen on demand.
        // Let's ensure initial render if needed.
        if (sim.animationPaused) { // Manually render one frame for initial setup visibility
            sim.renderer.render(sim.scene, sim.camera); 
            if(sim.composer) sim.composer.render(); // if post-processing is set up
        }

    </script>
</body>
</html>
