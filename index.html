<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Oscillator Synchronization Model</title>
    <style>
        :root {
            --bg-color: #000005;
            --panel-bg: rgba(20, 10, 50, 0.8);
            --accent-color: #00ccff;
            --text-color: #e0e0e0;
            --glow-color: rgba(120, 100, 255, 0.5);
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .panel {
            position: absolute;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--glow-color);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease, opacity 0.3s ease;
            z-index: 10;
        }

        .panel:hover {
            transform: translateY(-5px);
            opacity: 0.95;
        }

        #info {
            top: 20px;
            left: 20px;
            max-width: 350px;
            font-size: 14px;
        }

        #info h2 {
            margin: 0 0 10px;
            color: var(--accent-color);
        }

        #info p {
            margin: 8px 0;
            line-height: 1.5;
        }

        #resonanceStatus {
            color: #bbf0dd;
            margin-top: 10px;
            min-height: 3.5em;
            font-size: 0.95em;
        }

        #controls {
            top: 20px;
            right: 20px;
            max-width: 250px;
        }

        #controls label {
            display: flex;
            align-items: center;
            margin: 15px 0;
            font-size: 14px;
        }

        #controls input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent-color);
        }

        #controls button, #themeToggle, #pauseButton {
            margin: 10px 0;
            padding: 10px 20px;
            background: linear-gradient(45deg, var(--accent-color), #ff00cc);
            border: none;
            border-radius: 8px;
            color: #000;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        #controls button:hover, #themeToggle:hover, #pauseButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--accent-color);
        }

        #introOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 10, 0.95);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        #introContent {
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 15px;
            max-width: 700px;
            border: 1px solid var(--accent-color);
        }

        #introContent h1 {
            color: var(--accent-color);
            margin-bottom: 20px;
        }

        #introContent p {
            line-height: 1.6;
            margin-bottom: 15px;
            font-size: 0.95em;
        }

        #introContent strong {
            color: #aadeff;
        }

        #analyticsChart {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
            height: 150px;
            background: var(--panel-bg);
            border-radius: 8px;
            padding: 10px;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="introOverlay">
        <div id="introContent">
            <h1>Global Oscillator Synchronization Model</h1>
            <p>This visualization models a <strong>hypothetical scenario</strong> where oscillators (representing simplified "minds" with Theta/Alpha brainwave frequencies, ~4-8Hz) couple with each other and an external pacer (Earth's Schumann Resonance, ~7.83Hz).</p>
            <p>Using the <strong>Kuramoto model</strong>, explore emergent synchronization phenomena. Adjust parameters to observe collective coherence (order parameter 'r') and dynamic patterns.</p>
            <button id="startExperienceButton">Run Simulation with Audio</button>
        </div>
    </div>

    <div id="info" class="panel" role="region" aria-label="Simulation Information">
        <h2>Oscillator Network Dynamics</h2>
        <p>Internal Oscillators: 4–8 Hz (Theta/Alpha range).<br>External Pacer (Earth): ~7.83 Hz.</p>
        <p>Order Parameter (r): <span id="orderParameter">0.000</span></p>
        <div id="resonanceStatus">Initializing System...</div>
    </div>

    <div id="controls" class="panel" role="region" aria-label="Simulation Controls">
        <label for="coupling">Coupling (K): <span id="couplingValue">2.0</span></label>
        <input type="range" id="coupling" min="0" max="10" step="0.1" value="2" aria-valuemin="0" aria-valuemax="10" aria-valuenow="2">
        <label for="numBrains">Oscillators (N): <span id="numBrainsValue">300</span></label>
        <input type="range" id="numBrains" min="50" max="700" step="25" value="300" aria-valuemin="50" aria-valuemax="700" aria-valuenow="300">
        <label for="simSpeed">Sim Speed: <span id="simSpeedValue">0.3</span></label>
        <input type="range" id="simSpeed" min="0.05" max="1" step="0.05" value="0.3" aria-valuemin="0.05" aria-valuemax="1" aria-valuenow="0.3">
        <label for="alphaCoupling">Pacer Bal. (E↔C): <span id="alphaCouplingValue">0.5</span></label>
        <input type="range" id="alphaCoupling" min="0" max="1" step="0.05" value="0.5" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0.5">
        <label for="masterVolume">Volume: <span id="volumeValue">0.3</span></label>
        <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.3" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0.3">
        <button id="pauseButton">Pause</button>
        <button id="resetButton">Reset Simulation</button>
        <button id="themeToggle">Toggle Theme</button>
    </div>

    <canvas id="analyticsChart"></canvas>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/controls/OrbitControls.js';
        import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/postprocessing/ShaderPass.js';
        import { Chart } from 'https://cdn.jsdelivr.net/npm/chart.js';
        import tippy from 'https://unpkg.com/tippy.js@6';

        class OscillatorSimulation {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x050010, 0.05);
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
                this.composer = null;
                this.controls = null;
                this.audioCtx = null;
                this.masterGain = null;
                this.droneOsc = null;
                this.droneGain = null;
                this.droneLFO = null;
                this.droneLFOGain = null;
                this.pentatonicFrequencies = [];
                this.lastChimeTime = 0;
                this.CHIME_COOLDOWN = 300;
                this.lastRNormalizedForChime = 0;
                this.EARTH_RADIUS = 5;
                this.AURA_RADIUS_FACTOR = 1.08;
                this.F_E = 7.83;
                this.OMEGA_E = 2 * Math.PI * this.F_E;
                this.MIN_R_ORDER_FOR_CONNECTIONS = 0.25;
                this.CONNECTION_PHASE_THRESHOLD = Math.PI / 8;
                this.MAX_CONNECTIONS_TO_DISPLAY = 2500;
                this.EARTH_BASE_ROTATION_SPEED = 0.00015;
                this.N = 300;
                this.K = 2.0;
                this.SIMULATION_SPEED = 0.3;
                this.ALPHA_COUPLING = 0.5;
                this.r_order = 0;
                this.totalTime = 0;
                this.animationPaused = true;
                this.phases = [];
                this.intrinsicFrequencies = [];
                this.particleEnergy = [];
                this.frame_lastTime = 0;
                this.orderChart = null;
            }

            async initAudio() {
                try {
                    this.audioCtx = new AudioContext();
                    this.masterGain = this.audioCtx.createGain();
                    this.masterGain.gain.value = parseFloat(document.getElementById('masterVolume').value);
                    this.masterGain.connect(this.audioCtx.destination);

                    const filter = this.audioCtx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(1000, this.audioCtx.currentTime);

                    this.droneOsc = this.audioCtx.createOscillator();
                    this.droneGain = this.audioCtx.createGain();
                    this.droneLFO = this.audioCtx.createOscillator();
                    this.droneLFOGain = this.audioCtx.createGain();

                    this.droneOsc.type = 'sine';
                    this.droneOsc.frequency.setValueAtTime(this.F_E * 8, this.audioCtx.currentTime);
                    this.droneGain.gain.value = 0;

                    this.droneLFO.type = 'sine';
                    this.droneLFO.frequency.setValueAtTime(this.F_E, this.audioCtx.currentTime);

                    this.droneOsc.connect(this.droneGain);
                    this.droneGain.connect(filter);
                    filter.connect(this.masterGain);
                    this.droneLFO.connect(this.droneLFOGain);
                    this.droneLFOGain.connect(this.droneGain.gain);

                    this.droneLFOGain.gain.value = 0.0;
                    this.droneOsc.start();
                    this.droneLFO.start();

                    const rootFreq = 261.63;
                    const intervals = [0, 2, 4, 7, 9, 12, 14];
                    this.pentatonicFrequencies = intervals.map(interval => rootFreq * Math.pow(2, interval / 12));
                } catch (e) {
                    console.error('Audio initialization failed:', e);
                    document.getElementById('resonanceStatus').textContent = 'Audio unavailable. Simulation running without sound.';
                }
            }

            playPentatonicChime() {
                if (!this.audioCtx || this.audioCtx.currentTime - this.lastChimeTime < this.CHIME_COOLDOWN / 1000) return;
                this.lastChimeTime = this.audioCtx.currentTime;

                const freqIndex = Math.floor(Math.random() * this.pentatonicFrequencies.length);
                const frequency = this.pentatonicFrequencies[freqIndex];

                const chimeOsc = this.audioCtx.createOscillator();
                const chimeGain = this.audioCtx.createGain();

                chimeOsc.type = 'triangle';
                chimeOsc.frequency.setValueAtTime(frequency, this.audioCtx.currentTime);
                chimeGain.gain.setValueAtTime(0, this.audioCtx.currentTime);
                chimeGain.gain.linearRampToValueAtTime(0.4 * (0.2 + this.r_order * 0.8), this.audioCtx.currentTime + 0.05);
                chimeGain.gain.exponentialRampToValueAtTime(0.0001, this.audioCtx.currentTime + 1.2 + this.r_order);

                chimeOsc.connect(chimeGain).connect(this.masterGain);
                chimeOsc.start(this.audioCtx.currentTime);
                chimeOsc.stop(this.audioCtx.currentTime + 1.5 + this.r_order);
            }

            updateAudio() {
                if (!this.audioCtx) return;
                const targetDroneGain = 0.01 + this.r_order * 0.15;
                this.droneGain.gain.setTargetAtTime(targetDroneGain, this.audioCtx.currentTime, 0.1);
                const targetLFODepth = 0.05 + this.r_order * 0.4;
                this.droneLFOGain.gain.setTargetAtTime(targetLFODepth * targetDroneGain, this.audioCtx.currentTime, 0.1);

                const currentRNormalized = Math.floor(this.r_order * 10);
                if (currentRNormalized > this.lastRNormalizedForChime && this.r_order > 0.2) {
                    this.playPentatonicChime();
                    this.lastRNormalizedForChime = currentRNormalized;
                } else if (this.r_order < 0.1) {
                    this.lastRNormalizedForChime = 0;
                }
            }

            initScene() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.body.appendChild(this.renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0x706090, 0.8);
                this.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(5, 10, 7);
                this.scene.add(directionalLight);

                const renderPass = new RenderPass(this.scene, this.camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.9, 0.6, 0.5);
                bloomPass.threshold = 0.4;
                bloomPass.strength = 0.8;
                bloomPass.radius = 0.5;

                const vignettePass = new ShaderPass({
                    uniforms: {
                        tDiffuse: { value: null },
                        offset: { value: 1.0 },
                        darkness: { value: 1.0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D tDiffuse;
                        uniform float offset;
                        uniform float darkness;
                        varying vec2 vUv;
                        void main() {
                            vec4 color = texture2D(tDiffuse, vUv);
                            float dist = distance(vUv, vec2(0.5));
                            color.rgb *= smoothstep(0.8, offset * 0.799, dist * (darkness + offset));
                            gl_FragColor = color;
                        }
                    `
                });

                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(renderPass);
                this.composer.addPass(bloomPass);
                this.composer.addPass(vignettePass);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.minDistance = this.EARTH_RADIUS * 1.5;
                this.controls.maxDistance = this.EARTH_RADIUS * 5;

                this.camera.position.set(0, this.EARTH_RADIUS * 0.3, this.EARTH_RADIUS * 2.8);
                this.camera.lookAt(0, 0, 0);
            }

            initEarth() {
                if (this.earth) this.scene.remove(this.earth);
                const earthGeometry = new THREE.SphereGeometry(this.EARTH_RADIUS, 64, 64);
                const earthMaterial = new THREE.MeshStandardMaterial({
                    color: 0x204080,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.15,
                    emissive: 0x102040,
                    emissiveIntensity: 0.5,
                    roughness: 0.7,
                    metalness: 0.3
                });
                this.earth = new THREE.Mesh(earthGeometry, earthMaterial);
                this.scene.add(this.earth);
            }

            initAura() {
                if (this.aura) this.scene.remove(this.aura);
                const auraGeometry = new THREE.SphereGeometry(this.EARTH_RADIUS * this.AURA_RADIUS_FACTOR, 64, 64);
                const auraMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        orderParameter: { value: 0.0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        uniform float time;
                        void main() {
                            vUv = uv;
                            vec3 pos = position;
                            pos += normal * sin(time + pos.x * 2.0) * 0.05;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float orderParameter;
                        varying vec2 vUv;
                        void main() {
                            float glow = 0.3 + 0.7 * sin(time + vUv.x * 10.0 + vUv.y * 5.0);
                            vec3 color = mix(vec3(0.0, 0.6, 1.0), vec3(0.2, 0.8, 1.0), orderParameter);
                            gl_FragColor = vec4(color, 0.05 + orderParameter * 0.15 * glow);
                        }
                    `,
                    transparent: true,
                    wireframe: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                this.aura = new THREE.Mesh(auraGeometry, auraMaterial);
                this.scene.add(this.aura);
            }

            initParticles() {
                if (this.particleSystem) this.scene.remove(this.particleSystem);
                if (this.particlesGeometry) this.particlesGeometry.dispose();
                if (this.particleMaterial) this.particleMaterial.dispose();

                this.particlesGeometry = new THREE.InstancedBufferGeometry();
                const baseGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                this.particlesGeometry.copy(baseGeometry);

                const instancePositions = new Float32Array(this.N * 3);
                const instanceColors = new Float32Array(this.N * 3);
                const instanceSizes = new Float32Array(this.N);

                this.phases = [];
                this.intrinsicFrequencies = [];
                this.particleEnergy = [];

                for (let i = 0; i < this.N; i++) {
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r_particle = (0.2 + Math.random() * 0.7) * this.EARTH_RADIUS;
                    instancePositions[i * 3] = r_particle * Math.sin(phi) * Math.cos(theta);
                    instancePositions[i * 3 + 1] = r_particle * Math.sin(phi) * Math.sin(theta);
                    instancePositions[i * 3 + 2] = r_particle * Math.cos(phi);
                    instanceColors[i * 3] = 0.5;
                    instanceColors[i * 3 + 1] = 0.2;
                    instanceColors[i * 3 + 2] = 0.8;
                    instanceSizes[i] = 0.1 + Math.random() * 0.08;
                    this.phases.push(Math.random() * 2 * Math.PI);
                    this.intrinsicFrequencies.push(4 + Math.random() * 4);
                    this.particleEnergy.push(Math.random());
                }

                this.particlesGeometry.setAttribute('instancePosition', new THREE.InstancedBufferAttribute(instancePositions, 3));
                this.particlesGeometry.setAttribute('instanceColor', new THREE.InstancedBufferAttribute(instanceColors, 3));
                this.particlesGeometry.setAttribute('instanceSize', new THREE.InstancedBufferAttribute(instanceSizes, 1));

                this.particleMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        globalOrder: { value: 0.0 },
                        pulseFactor: { value: 1.0 }
                    },
                    vertexShader: `
                        attribute vec3 instancePosition;
                        attribute vec3 instanceColor;
                        attribute float instanceSize;
                        varying vec3 vColor;
                        uniform float time;
                        uniform float globalOrder;
                        uniform float pulseFactor;
                        void main() {
                            vColor = instanceColor;
                            vec4 mvPosition = modelViewMatrix * vec4(instancePosition, 1.0);
                            float pulse = 1.0 + 0.5 * sin(time * 5.0 + globalOrder * 10.0) * pulseFactor;
                            gl_Position = projectionMatrix * mvPosition;
                            gl_PointSize = instanceSize * (1.0 + globalOrder * 2.0) * pulse * (200.0 / -mvPosition.z);
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        uniform float time;
                        void main() {
                            float alpha = 0.55 + 0.45 * sin(time * 12.0 + gl_FragCoord.x * 0.15 + gl_FragCoord.y * 0.05);
                            if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.47) discard;
                            gl_FragColor = vec4(vColor, alpha);
                        }
                    `,
                    transparent: true,
                    vertexColors: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                this.particleSystem = new THREE.Mesh(this.particlesGeometry, this.particleMaterial);
                this.scene.add(this.particleSystem);
            }

            initResonancePlane() {
                if (this.resonancePlane) this.scene.remove(this.resonancePlane);
                const planeGeometry = new THREE.PlaneGeometry(this.EARTH_RADIUS * 3.5, this.EARTH_RADIUS * 3.5, 48, 48);
                const planeMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        orderParameter: { value: 0.0 },
                        baseColor: { value: new THREE.Color(0x55aaff) },
                        glowColor: { value: new THREE.Color(0xaadeff) }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        uniform float time;
                        uniform float orderParameter;
                        void main() {
                            vUv = uv;
                            vec3 pos = position;
                            float dist = length(pos.xy);
                            float wave1 = sin(dist * 3.0 - time * 2.5 + orderParameter * 7.0) * 0.2 * orderParameter;
                            float wave2 = cos(dist * 5.0 + time * 1.5 - orderParameter * 4.0) * 0.15 * orderParameter;
                            pos.z += (wave1 + wave2) * (1.0 - smoothstep(0.0, 8.0, dist));
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec2 vUv;
                        uniform float time;
                        uniform float orderParameter;
                        uniform vec3 baseColor;
                        uniform vec3 glowColor;
                        void main() {
                            float op = max(0.0, orderParameter - 0.1) * 3.0;
                            float pattern = 0.4 + 0.6 * sin(vUv.x * 30.0 + vUv.y * 5.0 + time * 2.0 + orderParameter * 15.0);
                            pattern *= (0.4 + 0.6 * cos(vUv.y * 25.0 - time * 1.5 + orderParameter * 10.0));
                            op = clamp(op * pattern, 0.0, 0.8);
                            float edgeFactor = 1.0 - smoothstep(0.30, 0.5, length(vUv - 0.5));
                            op *= edgeFactor;
                            vec3 color = mix(baseColor, glowColor, smoothstep(0.15, 0.75, orderParameter));
                            gl_FragColor = vec4(color, op);
                        }
                    `,
                    side: THREE.DoubleSide,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });
                this.resonancePlane = new THREE.Mesh(planeGeometry, planeMaterial);
                this.resonancePlane.rotation.x = Math.PI / 2;
                this.resonancePlane.position.y = -this.EARTH_RADIUS * 0.05;
                this.scene.add(this.resonancePlane);
            }

            initLineConnections() {
                if (this.lineConnectionSystem) this.scene.remove(this.lineConnectionSystem);
                if (this.lineGeometry) this.lineGeometry.dispose();
                if (this.lineMaterial) this.lineMaterial.dispose();
                this.lineGeometry = new THREE.BufferGeometry();
                this.lineMaterial = new THREE.LineBasicMaterial({
                    color: 0x99bbff,
                    transparent: true,
                    opacity: 0,
                    linewidth: 1,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                this.lineConnectionSystem = new THREE.LineSegments(this.lineGeometry, this.lineMaterial);
                this.scene.add(this.lineConnectionSystem);
            }

            initChart() {
                const ctx = document.getElementById('analyticsChart').getContext('2d');
                this.orderChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Order Parameter (r)',
                            data: [],
                            borderColor: '#00ccff',
                            backgroundColor: 'rgba(0, 204, 255, 0.2)',
                            fill: false,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { display: false },
                            y: { min: 0, max: 1, title: { display: true, text: 'r' } }
                        },
                        plugins: { legend: { labels: { color: '#e0e0e0' } } }
                    }
                });
            }

            updateChart() {
                this.orderChart.data.labels.push(this.totalTime.toFixed(2));
                this.orderChart.data.datasets[0].data.push(this.r_order);
                if (this.orderChart.data.labels.length > 100) {
                    this.orderChart.data.labels.shift();
                    this.orderChart.data.datasets[0].data.shift();
                }
                this.orderChart.update();
            }

            updatePhases(deltaTimeEffective) {
                if (this.animationPaused || !this.phases || this.phases.length !== this.N || this.N === 0 || !this.particlesGeometry) return;
                const earthPhase = (this.OMEGA_E * this.totalTime) % (2 * Math.PI);
                let sumCos = 0, sumSin = 0;
                for (let i = 0; i < this.N; i++) {
                    sumCos += Math.cos(this.phases[i]);
                    sumSin += Math.sin(this.phases[i]);
                }
                this.r_order = this.N > 0 ? Math.sqrt(sumCos * sumCos + sumSin * sumSin) / this.N : 0;
                const psi_collective = this.N > 0 ? Math.atan2(sumSin, sumCos) : 0;
                const currentParticleColors = this.particlesGeometry.attributes.instanceColor.array;
                const currentParticlePositions = this.particlesGeometry.attributes.instancePosition.array;
                const tempColor = new THREE.Color();

                for (let i = 0; i < this.N; i++) {
                    const omega_i = 2 * Math.PI * this.intrinsicFrequencies[i];
                    const earthInteractionTerm = (1 - this.ALPHA_COUPLING) * this.K * Math.sin(earthPhase - this.phases[i]);
                    const collectiveInteractionTerm = this.ALPHA_COUPLING * this.K * this.r_order * Math.sin(psi_collective - this.phases[i]);
                    this.phases[i] += (omega_i + earthInteractionTerm + collectiveInteractionTerm) * deltaTimeEffective;
                    this.phases[i] = (this.phases[i] % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
                    const phaseDifferenceToEarth = Math.abs(this.phases[i] - earthPhase) % (2 * Math.PI);
                    const syncFactorEarth = Math.cos(phaseDifferenceToEarth / 2);
                    const phaseDifferenceToCollective = Math.abs(this.phases[i] - psi_collective) % (2 * Math.PI);
                    const syncFactorCollective = Math.cos(phaseDifferenceToCollective / 2);
                    this.particleEnergy[i] = THREE.MathUtils.lerp(this.particleEnergy[i], (syncFactorEarth + syncFactorCollective) / 2, 0.1);
                    const hue = 0.6 + this.particleEnergy[i] * 0.3;
                    const saturation = 0.5 + this.particleEnergy[i] * 0.5;
                    const lightness = 0.4 + this.particleEnergy[i] * 0.4;
                    tempColor.setHSL(hue, saturation, lightness);
                    currentParticleColors[i * 3] = tempColor.r;
                    currentParticleColors[i * 3 + 1] = tempColor.g;
                    currentParticleColors[i * 3 + 2] = tempColor.b;
                    currentParticlePositions[i * 3 + 1] += (Math.random() - 0.5) * 0.005 * (1 - this.particleEnergy[i]);
                    const distSq = currentParticlePositions[i * 3] ** 2 + currentParticlePositions[i * 3 + 1] ** 2 + currentParticlePositions[i * 3 + 2] ** 2;
                    if (distSq > (this.EARTH_RADIUS * 0.9) ** 2) {
                        currentParticlePositions[i * 3] *= 0.995;
                        currentParticlePositions[i * 3 + 1] *= 0.995;
                        currentParticlePositions[i * 3 + 2] *= 0.995;
                    }
                }
                this.particlesGeometry.attributes.instancePosition.needsUpdate = true;
                this.particlesGeometry.attributes.instanceColor.needsUpdate = true;
                if (this.resonancePlane) {
                    this.resonancePlane.material.uniforms.orderParameter.value = this.r_order;
                    this.resonancePlane.material.uniforms.time.value = this.totalTime;
                    const planeScale = 1 + this.r_order * this.K * 0.02;
                    this.resonancePlane.scale.set(planeScale, planeScale, 1);
                }
                if (this.particleMaterial) {
                    this.particleMaterial.uniforms.time.value = this.totalTime;
                    this.particleMaterial.uniforms.globalOrder.value = this.r_order;
                }
            }

            updateConnections() {
                if (this.animationPaused || !this.lineConnectionSystem || !this.particlesGeometry || this.N === 0) {
                    if (this.lineConnectionSystem) this.lineConnectionSystem.material.opacity = 0;
                    return;
                }
                const lineVertices = [];
                let connectionsDrawn = 0;
                const particlePos = this.particlesGeometry.attributes.instancePosition.array;
                if (this.r_order > this.MIN_R_ORDER_FOR_CONNECTIONS) {
                    for (let i = 0; i < this.N; i++) {
                        if (connectionsDrawn >= this.MAX_CONNECTIONS_TO_DISPLAY) break;
                        for (let j = i + 1; j < this.N; j++) {
                            if (connectionsDrawn >= this.MAX_CONNECTIONS_TO_DISPLAY) break;
                            let phaseDiff = Math.abs(this.phases[i] - this.phases[j]);
                            phaseDiff = Math.min(phaseDiff, 2 * Math.PI - phaseDiff);
                            if (phaseDiff < this.CONNECTION_PHASE_THRESHOLD * (1.5 - this.particleEnergy[i]) * (1.5 - this.particleEnergy[j])) {
                                const connectionStrength = this.particleEnergy[i] * this.particleEnergy[j];
                                if (Math.random() < connectionStrength * 0.5) {
                                    lineVertices.push(particlePos[i * 3], particlePos[i * 3 + 1], particlePos[i * 3 + 2]);
                                    lineVertices.push(particlePos[j * 3], particlePos[j * 3 + 1], particlePos[j * 3 + 2]);
                                    connectionsDrawn++;
                                }
                            }
                        }
                    }
                }
                if (lineVertices.length > 0) {
                    this.lineConnectionSystem.geometry.setAttribute('position', new THREE.Float32BufferAttribute(lineVertices, 3));
                    this.lineConnectionSystem.geometry.attributes.position.needsUpdate = true;
                    const baseOpacity = Math.min(0.05, (this.r_order - this.MIN_R_ORDER_FOR_CONNECTIONS) * 0.5);
                    this.lineConnectionSystem.material.opacity = baseOpacity + Math.min(0.5, this.r_order * 0.8);
                    const lineHue = 0.55 + this.r_order * 0.3;
                    this.lineConnectionSystem.material.color.setHSL(lineHue, 0.7, 0.5 + this.r_order * 0.2);
                } else {
                    this.lineConnectionSystem.material.opacity = 0;
                }
            }

            updateResonanceStatusText() {
                const el = document.getElementById('resonanceStatus');
                if (this.animationPaused && !this.audioCtx) {
                    el.textContent = "Click 'Run Simulation' to begin.";
                    return;
                }
                if (this.animationPaused && this.audioCtx) {
                    el.textContent = "Simulation Paused. Audio may continue.";
                    return;
                }
                if (this.r_order < 0.15) el.textContent = "Low Coherence: Oscillators unsynchronized.";
                else if (this.r_order < 0.35) el.textContent = "Emerging Coherence: Partial phase-locking.";
                else if (this.r_order < 0.6) el.textContent = "Significant Coherence: Strong synchronization.";
                else el.textContent = "High Global Coherence: Near full synchronization.";
            }

            animate(time) {
                requestAnimationFrame((t) => this.animate(t));
                if (this.animationPaused && time !== 0) return;
                const now = time * 0.001;
                const deltaTime = now - this.frame_lastTime;
                this.frame_lastTime = now;
                const effectiveDeltaTime = Math.min(deltaTime, 0.1) * this.SIMULATION_SPEED;
                if (this.N > 0 && this.phases && this.phases.length > 0) {
                    this.totalTime += effectiveDeltaTime;
                }

                if (this.earth) {
                    this.earth.rotation.y += this.EARTH_BASE_ROTATION_SPEED * this.SIMULATION_SPEED * 60 * deltaTime;
                    this.earth.material.emissiveIntensity = 0.3 + this.r_order * 0.4;
                    this.earth.material.opacity = 0.1 + this.r_order * 0.08;
                }
                if (this.aura) {
                    this.aura.rotation.y += (this.EARTH_BASE_ROTATION_SPEED * 1.5) * this.SIMULATION_SPEED * 60 * deltaTime;
                    this.aura.rotation.x += (this.EARTH_BASE_ROTATION_SPEED * 0.8) * this.SIMULATION_SPEED * 60 * deltaTime;
                    const pulse = 1 + 0.05 * Math.sin(this.totalTime * this.OMEGA_E * 0.2) * (1 + this.K * 0.01 + this.r_order * 1.5);
                    this.aura.scale.set(pulse, pulse, pulse);
                    this.aura.material.uniforms.time.value = this.totalTime;
                    this.aura.material.uniforms.orderParameter.value = this.r_order;
                }

                if (this.N > 0 && this.phases && this.phases.length > 0) {
                    this.updatePhases(effectiveDeltaTime);
                    this.updateConnections();
                } else {
                    this.updateConnections();
                }

                this.updateAudio();
                document.getElementById('orderParameter').textContent = this.r_order.toFixed(3);
                this.updateResonanceStatusText();
                this.updateChart();
                this.controls.update();
                this.composer.render();
            }

            resetSimulation() {
                this.K = 2.0;
                this.N = parseInt(document.getElementById('numBrains').value);
                this.SIMULATION_SPEED = 0.3;
                this.ALPHA_COUPLING = 0.5;
                document.getElementById('coupling').value = this.K;
                document.getElementById('simSpeed').value = this.SIMULATION_SPEED;
                document.getElementById('alphaCoupling').value = this.ALPHA_COUPLING;
                document.getElementById('couplingValue').textContent = this.K.toFixed(1);
                document.getElementById('simSpeedValue').textContent = this.SIMULATION_SPEED.toFixed(2);
                document.getElementById('alphaCouplingValue').textContent = this.ALPHA_COUPLING.toFixed(2);
                this.totalTime = 0;
                this.r_order = 0;
                this.lastRNormalizedForChime = 0;
                document.getElementById('orderParameter').textContent = this.r_order.toFixed(3);
                if (this.N > 0 && !this.animationPaused) {
                    this.initParticles();
                    this.updateConnections();
                }
                this.orderChart.data.labels = [];
                this.orderChart.data.datasets[0].data = [];
                this.orderChart.update();
                this.updateResonanceStatusText();
            }

            init() {
                this.initScene();
                this.initEarth();
                this.initAura();
                this.initParticles();
                this.initResonancePlane();
                this.initLineConnections();
                this.initChart();

                document.getElementById('couplingValue').textContent = this.K.toFixed(1);
                document.getElementById('numBrainsValue').textContent = this.N;
                document.getElementById('simSpeedValue').textContent = this.SIMULATION_SPEED.toFixed(2);
                document.getElementById('alphaCouplingValue').textContent = this.ALPHA_COUPLING.toFixed(2);
                document.getElementById('volumeValue').textContent = parseFloat(document.getElementById('masterVolume').value).toFixed(2);

                document.getElementById('coupling').addEventListener('input', (e) => {
                    this.K = parseFloat(e.target.value);
                    document.getElementById('couplingValue').textContent = this.K.toFixed(1);
                });
                document.getElementById('numBrains').addEventListener('input', (e) => {
                    this.N = parseInt(e.target.value);
                    document.getElementById('numBrainsValue').textContent = this.N;
                    if (this.N > 0 && !this.animationPaused) {
                        this.initParticles();
                        this.updateConnections();
                    }
                });
                document.getElementById('simSpeed').addEventListener('input', (e) => {
                    this.SIMULATION_SPEED = parseFloat(e.target.value);
                    document.getElementById('simSpeedValue').textContent = this.SIMULATION_SPEED.toFixed(2);
                });
                document.getElementById('alphaCoupling').addEventListener('input', (e) => {
                    this.ALPHA_COUPLING = parseFloat(e.target.value);
                    document.getElementById('alphaCouplingValue').textContent = this.ALPHA_COUPLING.toFixed(2);
                });
                document.getElementById('masterVolume').addEventListener('input', (e) => {
                    if (this.masterGain) this.masterGain.gain.value = parseFloat(e.target.value);
                    document.getElementById('volumeValue').textContent = parseFloat(e.target.value).toFixed(2);
                });
                document.getElementById('pauseButton').addEventListener('click', () => {
                    this.animationPaused = !this.animationPaused;
                    document.getElementById('pauseButton').textContent = this.animationPaused ? 'Resume' : 'Pause';
                    this.updateResonanceStatusText();
                });
                document.getElementById('resetButton').addEventListener('click', () => this.resetSimulation());
                document.getElementById('startExperienceButton').addEventListener('click', async () => {
                    await this.initAudio();
                    document.getElementById('introOverlay').style.display = 'none';
                    this.animationPaused = false;
                    if (this.N > 0) {
                        this.initParticles();
                        this.updateConnections();
                    }
                    this.animate(0);
                });
                document.getElementById('themeToggle').addEventListener('click', () => {
                    document.documentElement.style.setProperty('--bg-color', document.documentElement.style.getPropertyValue('--bg-color') === '#000005' ? '#f0f0f5' : '#000005');
                    document.documentElement.style.setProperty('--panel-bg', document.documentElement.style.getPropertyValue('--panel-bg') === 'rgba(20, 10, 50, 0.8)' ? 'rgba(255, 255, 255, 0.8)' : 'rgba(20, 10, 50, 0.8)');
                    document.documentElement.style.setProperty('--text-color', document.documentElement.style.getPropertyValue('--text-color') === '#e0e0e0' ? '#333333' : '#e0e0e0');
                    this.orderChart.options.plugins.legend.labels.color = document.documentElement.style.getPropertyValue('--text-color');
                    this.orderChart.update();
                });

                tippy('#coupling', { content: 'Controls the strength of interaction between oscillators and the external pacer.' });
                tippy('#numBrains', { content: 'Number of oscillators in the simulation.' });
                tippy('#simSpeed', { content: 'Adjusts the speed of the simulation.' });
                tippy('#alphaCoupling', { content: 'Balances coupling between external pacer and collective oscillators.' });
                tippy('#masterVolume', { content: 'Controls the audio volume of the simulation.' });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.composer.setSize(window.innerWidth, window.innerHeight);
                });

                this.updateResonanceStatusText();
            }
        }

        const sim = new OscillatorSimulation();
        sim.init();
    </script>
</body>
</html>
